# セマンティックバージョニング（SemVer）＋互換ポリシー：16章アウトライン📘✨

Windows🪟＋VS Code🧑‍💻＋TypeScript（2026最新版想定）✨＋AI拡張（Copilot / Codex等）🤖✅
対象：TS初級〜中級／SemVer初めて／設計超入門🌱

* **Part A：基礎の基礎（1〜4章）**：SemVerを「言葉」でなく「感覚」で掴む😊
* **Part B：互換性＝約束（5〜9章）**：公開APIと破壊的変更を判断できるようにする🧠
* **Part C：依存管理（10〜12章）**：npm運用で事故を減らす🛡️
* **Part D：リリース運用（13〜16章）**：非推奨・プレリリース・自動化・卒制で完成🎉

---

## 第1章　バージョンで何が変わるの？📦😵‍💫

![Update Fail Reaction](./picture/svbc_ts_index_update_fail_reaction.png)

**できるようになる**：バージョンが「誰を安心させる仕組み」かわかる

* あるある：更新したら壊れた💥（利用者の世界を想像する👀）
* 「互換性」「契約」「約束」って何？🤝
* SemVerと互換ポリシーは“安心の設計”🧩
  **ミニ演習**：自分が使ってるライブラリを1つ選んで「公開APIっぽいもの」を3つ書く📝
  **AI活用🤖**：選んだライブラリの「利用者が頼ってる部分」を言語化させる

---

## 第2章　SemVerの超基本：MAJOR/MINOR/PATCH🔢✨

![SemVer Blocks](./picture/svbc_ts_index_semver_blocks.png)

**できるようになる**：3つの番号の役割を説明できる

* `MAJOR.MINOR.PATCH` の意味（ざっくりでOK）
* “壊れる変更”＝MAJOR💔、“機能追加”＝MINOR✨、“バグ修正”＝PATCH🐛
* 「互換」って“誰に対して”の互換？（利用者視点👥）
  **ミニ演習**：変更例を10個見て「どれ上げる？」クイズ🎯
  **AI活用🤖**：クイズの解説を「初心者向けに」言い換えさせる

---

## 第3章　0.x と 1.0.0 の意味（ここ超大事）🚧➡️🏁

![Zero vs One](./picture/svbc_ts_index_zero_vs_one.png)

**できるようになる**：0系での“約束の弱さ”を理解する

* 0.xは「まだ固まってないよ」期間になりやすい🚧
* 1.0.0は「ここから契約を守る」宣言🏁
* “いつ1.0にする？”判断基準（公開APIが固まったら）🧱
  **ミニ演習**：自分の小プロジェクトを「0.xでOKか？1.0にしたいか？」判断して理由を書く📝
  **AI活用🤖**：判断理由の文章を短く整える（README向け）

---

## 第4章　SemVerが効く範囲：まず「公開API」を決めよう📣🧱

![Public API Iceberg](./picture/svbc_ts_index_public_api_iceberg.png)

**できるようになる**：「約束するもの／しないもの」を分けられる

* 公開APIの例：export関数、export型、イベント、設定、CLIコマンドなど🧰
* 非公開（内部）は自由に壊してOK（でも漏れると事故る）🙅‍♀️
* “何を公開扱いにするか”が互換ポリシーの出発点🚀
  **ミニ演習**：自作モジュールで「公開API」「内部」を線引きする✍️
  **AI活用🤖**：公開API一覧（箇条書き）を自動生成させる

---

## 第5章　互換性の種類：壊れるって具体的に何が壊れるの？💥🔍

**できるようになる**：「破壊的変更」の定義を持てる

* 破壊的変更＝利用者コードが動かない／コンパイル通らない／挙動が変わる😱
* 3カテゴリで理解：

  1. **コンパイル破壊**（型が変わる等）🧷
  2. **実行時破壊**（例外になる等）💣
  3. **意味の破壊**（結果の意味が変わる）🌀
     **ミニ演習**：変更例をカテゴリ分けしてみる📦
     **AI活用🤖**：変更の“破壊ポイント”を言語化させる

---

## 第6章　TypeScriptの地雷①：型の変更はどう壊れる？🧷⚠️

**できるようになる**：型変更の危険パターンがわかる

* 引数型・戻り値型の変更は基本危険⚠️
* optional → required は壊れやすい😵
* unionの削除、リテラルの削除、enumの変更の怖さ🧊
  **ミニ演習**：簡単な関数に対して「壊れる型変更」を3つ作ってみる🧪
  **AI活用🤖**：その変更が“なぜMAJORか”を文章で説明させる

---

## 第7章　TypeScriptの地雷②：exportの変更と“見えてる面”📤👀

![Export Shop Window](./picture/svbc_ts_index_export_shop_window.png)

**できるようになる**：公開面（API surface）という考え方を掴む

* export名の変更＝ほぼ破壊💥
* exportの削除＝完全に破壊🗑️
* export型のちょい変更が大事故になる例😇
  **ミニ演習**：`index.ts`の公開面を設計してみる（どれをexportする？）🧩
  **AI活用🤖**：公開面のレビュー役をAIにやらせる（「これ公開で大丈夫？」）

---

## 第8章　互換ポリシー①：最小の“約束文”を作る📜✨

**できるようになる**：互換ポリシーを短文で書ける

* 最小セット（まずこれだけでOK）✅

  * 公開APIの定義
  * MAJOR/MINOR/PATCHの基準
  * 非推奨の方針
* READMEに貼れるテンプレを作る📌
  **ミニ演習**：自分の互換ポリシーを「6行」で書く📝
  **AI活用🤖**：文章を“やさしく・短く”整える（女子大生向け口調でもOK）

---

## 第9章　互換ポリシー②：サポート範囲（環境）も約束に入れる🌍🧭

**できるようになる**：互換性の“外側”も設計できる

* TypeScript/Node.js/ブラウザ対応などの考え方（2026想定）✨
* 「サポート終了（EOL）」の扱いをどう書く？🕰️
* 互換ポリシーに含める/含めないの線引き🧱
  **ミニ演習**：サポート範囲を「今はこれだけ」で決める（例：Node LTS）📝
  **AI活用🤖**：想定ユーザー（利用者）を1〜2パターン作って、困る点を洗い出す

---

## 第10章　依存管理①：`^` `~` 固定 の違いを体感する🎚️🧨

![Npm Ranges](./picture/svbc_ts_index_npm_ranges.png)

**できるようになる**：npmのバージョン範囲の“事故り方”がわかる

* `^` はどこまで上がる？ `~` はどこまで？ 固定は？📌
* “SemVerを守ってる前提”が崩れるとどうなる？😇
* 安全寄り運用の基本方針🛡️
  **ミニ演習**：3パターンで依存指定して、更新の挙動を想像クイズ🎯
  **AI活用🤖**：自分のプロジェクトに合う指定方針を提案させる

---

## 第11章　依存管理②：lockfileの意味（あなたを守る盾）🔒🛡️

![Lockfile Shield](./picture/svbc_ts_index_lockfile_shield.png)

**できるようになる**：lockfileの役割を説明できる

* lockfileがあると「同じ依存が再現できる」📌
* チーム/CIでの事故が減る理由👥
* 更新するタイミングのルール（いつ regenerate する？）🧹
  **ミニ演習**：依存更新の“手順メモ”（自分用）を作る📝
  **AI活用🤖**：更新手順をチェックリスト化させる✅

---

## 第12章　依存管理③：peerDependencies と “相性問題”🤝💥

**できるようになる**：プラグイン系で事故らない

* peerDependenciesは「同じ土台を使ってね」合図🏗️
* どんなとき必要？（React系・プラグイン系など）🎛️
* 相性問題を互換ポリシーにどう書く？📝
  **ミニ演習**：架空のプラグインを想定してpeerDependenciesを書いてみる✍️
  **AI活用🤖**：想定される利用者のエラーを列挙させる（予防線）

---

## 第13章　変更の分類が上手くなる：迷ったときの判断ルール🧠🧭

**できるようになる**：迷いが減る（これ超うれしい）✨

* 変更分類の“判断順”を固定する（テンプレ化）📌

  1. 公開APIに触れてる？
  2. 利用者コードが壊れる？
  3. 意味が変わる？
* 「型を厳しくしたい」問題の扱い（ケース分け）🤔
  **ミニ演習**：20問の分類トレーニング（MAJOR/MINOR/PATCH）🎯
  **AI活用🤖**：AIに採点と解説をさせる（“なぜ？”が大事）

---

## 第14章　非推奨（Deprecation）で“やさしく壊す”🧓➡️🆕

**できるようになる**：破壊を段階的に進められる

* いきなり削除＝炎上🔥（未来の自分も泣く😭）
* 3段階：非推奨→代替→次のMAJORで削除🪜
* 移行ガイドの最小テンプレ（1ページ）📄✨
  **ミニ演習**：非推奨コメント＆移行ガイドを作る📝
  **AI活用🤖**：移行ガイドを「短く・親切に」リライトさせる

---

## 第15章　プレリリースと実験：alpha/beta/rcの使い分け🧪🚧

**できるようになる**：安全に試してもらえる

* `-alpha` `-beta` `-rc` の感覚🧪
* 実験API（experimental）をどう扱う？🚩
* “試用”と“本番”の境界線を引く🧱
  **ミニ演習**：実験機能を1つ作った想定で、公開の仕方を設計する📦
  **AI活用🤖**：実験機能の注意書きを作らせる（誤解防止）

---

## 第16章　リリース運用：リリースノート＋自動化＋AIでラクする🚀🤖✨

**できるようになる**：「出す」ところまで回せる

* リリースの基本セット🧰

  * 変更点まとめ（Changelog / Release Notes）📝
  * タグ付け🏷️
  * CIでチェック（テスト/型チェック）✅
* “互換性チェック”の仕組みを運用に混ぜる（最低限でOK）🛡️
* AI活用ポイント🤖

  * コミットやPRからリリースノート生成🧾
  * 破壊的変更の可能性チェック🔍
  * 利用者向け説明のやさしい言い換え💬
    **ミニ演習（卒業制作🎓）**：
* 小さなTSライブラリを想定して

  * `0.1.0`（実験）→ `1.0.0`（契約宣言）→ `1.1.0`（機能追加）→ `2.0.0`（非推奨→削除）
    のストーリーで“リリースノート付き”で完成させる🎉

---

## おまけ：この16章で育つ“最終スキル”🌱➡️🌳

* 変更を見た瞬間に「これはMAJOR？」って判断できる👀✨
* READMEに互換ポリシーを書ける📜
* 非推奨→移行→削除の流れを設計できる🪜
* 依存更新の事故が減る🛡️
* リリースが“儀式”じゃなく“手順”になる🚀

