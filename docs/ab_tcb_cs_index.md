# 32章アウトライン（集約とトランザクション境界）🌸📘

* Windows + Visual Studio 2026（基本）🪟💻
* VS Code は「必要な章だけ」併用OK✌️
* C#（2026年の最新想定）＋ .NET（同世代の最新想定）で進めるよ🚀
* Copilot / CodexなどAI拡張は「使える前提」で毎章ちょこちょこ使う🤖✨

### 第1章：この教材のゴール🎯✨

* 何ができるようになる？（集約を切れる／境界を置ける）💪
* 「整合性バグを減らす」ってどういう意味？🧠
* 最後に作るミニアプリのイメージ☕️📦

### 第2章：開発環境の準備（Windows + VS）🪟🛠️

* Visual Studioでソリューション作成の流れ📁
* Gitの最小運用（コミット粒度のコツ）🐙
* AI拡張の使い方ルール（丸投げ禁止の型）🤖⚠️

### 第3章：DDDってなに？こわくない版🧁

* DDD＝業務の言葉をコードにする📖
* “難しいやつ全部”は後回しでOK🙆‍♀️
* 今日の主役「集約」だけ先に理解しよう🌟

### 第4章：トランザクションってなに？🔒

* 「全部成功 or 全部失敗」💥
* どこまでを1回で守るの？＝境界の話🧱
* まずは「1ユースケース＝1トランザクション」から😊

---

### 第5章：整合性ってなに？（即時 vs あとでOK）⏱️⏳

* “絶対守るルール”と“後で揃えばOK”の分け方⚖️
* UX（表示や文言）で不安を減らすコツ💬
* 例：支払い直後に発送が即反映じゃなくてもOK？🤔

### 第6章：EntityとValueObject（最小でOK）🧩

* Entity＝IDで追う👤 / VO＝値そのもの💰
* VOにするとバグが減る系（住所・金額・期間）🏠📅
* 集約の中でVOが効く理由✨

### 第7章：ユースケースと「境界」の関係🎬

* ユースケース＝ユーザーがやりたい1行動👆
* 境界＝その1行動で守る整合性の範囲🔒
* “境界はDBの都合じゃなく業務の都合”で決める🧠

### 第8章：題材ドメイン紹介（カフェ注文）☕️🍰

* Order / OrderItem / Payment / Customer などを登場させる👀
* ありがちな業務ルールを先に並べる📋
* AIに「ありそうなルール」を出させる🤖✨

### 第9章：ユビキタス言語（言葉合わせ）🗣️🌸

* 用語がズレると設計が壊れる😵
* “注文確定”と“支払い完了”の違いを言語化✅
* 小さな辞書を作る（1ページでOK）📖

### 第10章：最初のモデル図を描こう📦➡️

* 箱（概念）と線（関係）でOK✍️
* “更新される単位”に注目して描く👀
* ここで「集約の候補」をふわっと置く🌳

---

### 第11章：集約（Aggregate）ってなに？🌳

* 集約＝一貫性を守る“まとまり”😊
* 目的＝整合性バグを激減させる🛡️
* 集約は「大きいほど良い」じゃない⚠️

### 第12章：集約ルート（入口は1つ）👑🚪

* 外からはルート経由でしか更新できない🙅‍♀️
* ルートが不変条件を守る責任者✨
* “直接いじれない”が安全の鍵🔐

### 第13章：境界の判断軸①「同時に守る必要がある？」🧠⚖️

* 1回の更新で必ず守りたいルールはどれ？✅
* 「同じトランザクションで守りたいもの」を探す🔍
* 例：注文確定と明細追加は一緒？🤔

### 第14章：境界の判断軸②「参照はIDで持つ」🆔

* 他集約をオブジェクト参照しない（密結合防止）🧷
* 参照が必要なら Query で取りに行く🔎
* “更新はルート、参照は別”の感覚✨

### 第15章：境界の判断軸③「サイズ調整」⚖️😇

* 巨大集約の地獄（変更しにくい／遅い）💥
* 小さすぎ集約の地獄（跨ぎ更新したくなる）😵
* “だいたいこのくらい”の目安を持つ📏

### 第16章：境界を切る練習（ワーク3本）✍️🎀

* ケース1：カフェ注文（基本）☕️
* ケース2：サブスク課金（更新と参照が分かれやすい）💳
* ケース3：在庫引当（跨ぎ更新の誘惑が強い）📦
* AIに「境界案を3パターン」出させて比較🤖✨

---

### 第17章：不変条件（Invariants）ってなに？🔐

* “必ず守るルール”を散らさない📌
* 途中状態を壊さないための考え方🧠
* 例：「確定後は明細を追加できない」🧾🚫

### 第18章：C#で不変条件を守る①（生成とガード節）🛠️

* コンストラクタ/ファクトリで無効状態を作らない🏗️
* ガード節（早めに弾く）で安全に✨
* public setter禁止の理由（勝手に壊される）😇

### 第19章：C#で不変条件を守る②（更新メソッドと状態遷移）🔁

* “変更はメソッドに閉じ込める”✋
* 状態（Status）で許可/禁止を表現する🚦
* 後で状態機械に繋がる下地を作る🌈

### 第20章：ドメインエラーの設計（初心者向け）💬⚠️

* 例外をどこまで投げる？Result型は？🤔
* “ユーザーに見せるメッセージ”と“ログの詳細”を分ける🧾
* 境界（アプリ層）でエラーを整形する✨

---

### 第21章：レイヤード構成（置き場所で迷子にならない）🗂️

* Domain / Application / Infrastructure の役割ざっくり📚
* “ドメインはインフラを参照しない”ルール🧱
* Visual Studioのプロジェクト/フォルダ例📁

### 第22章：Repositoryは「集約単位」🏪

* OrderRepositoryはOK、OrderItemRepositoryは基本NG🙅‍♀️
* 取り出し/保存は集約ルート単位でやる🚪
* interface化して差し替えできるようにする🌟

### 第23章：Unit of Workの感覚（DbContextの立ち位置）🧠

* 変更をまとめて確定する仕組み💾
* “いつ確定するか”が境界そのもの🔒
* まずは難語を使わず感覚で掴む😊

### 第24章：EF Core導入（最小セット）🧪

* DbContext / DbSet の最小理解✨
* マッピング（Entity/VOの扱いの入口）🧩
* 開発用DB（ローカルで軽く回す）🪶

---

### 第25章：トランザクション境界の置き場所（結論：アプリ層）🎬🔒

* 基本：Application Service（ユースケース）に置く😊
* Domainはトランザクションを知らない方がキレイ✨
* 「1ユースケース＝1境界」の型を固める📌

### 第26章：「1ユースケース＝1トランザクション」実装💾✅

* 例：PlaceOrder（注文確定）を1回で完結させる☕️
* SaveChangesの位置を固定する🎯
* “途中で外部I/Oしない”の基本もセットで🧷

### 第27章：明示トランザクションが必要な場面だけ🔒🧠

* 基本は不要、必要なときだけ使う（理由つきで）👌
* 複数保存や整合性の要件で判断する⚖️
* AIに「このケース必要？」を聞いて根拠を確認🤖

---

### 第28章：同時更新って何が起きる？（事故から入る）🚑😅

* あるある：同じ注文を2人が同時に編集💥
* 何が壊れる？（上書き・二重処理）😵
* “検出できるだけでも価値”を理解する✨

### 第29章：楽観ロック（RowVersion）を入れてみる⚔️

* RowVersionの考え方（ぶつかったら止める）🧱
* 衝突時の挙動（再試行／やり直し）🔁
* ユーザー向け表示をやさしくする💬🌸

---

### 第30章：跨ぎ更新がしたくなる病（でも基本NG）🙅‍♀️😇

* 巨大トランザクション地獄の話💥
* “境界を守る”＝未来の自分を守る🛡️
* 代わりの手段へ橋渡し（イベント／後処理）🌉

### 第31章：ドメインイベントと最終的整合性（入門）📣⏳

* イベント＝「起きた事実」（過去形）✅
* 集約内で発行 → 外で処理（疎結合）🧠
* 状態（ステータス）で「いま何中」を見せる👀
* ちいさな状態機械っぽい表を作る🚦

### 第32章：Outboxと冪等性（現実運用の最低ライン）📮🔁

* 取りこぼし/二重送信の怖さを知る😱
* Outboxの“考え方”を理解（まず概念でOK）📮
* 冪等性キーで二重処理を防ぐ🗝️
* 総合ミニ課題：

  * 「注文確定→支払い→（遅れて）発送準備」まで一連で設計してみる☕️📦
  * “どこが即時整合で、どこが最終的整合か”を言葉で説明できたら勝ち🏆✨
* おまけ：次に進むなら（Saga / CQRS / 状態機械の深掘り）🚀


